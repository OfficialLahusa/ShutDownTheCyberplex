#BlueJ class context
comment0.target=CircleCollider
comment0.text=\r\n\ Kreis-Collider\ mit\ Mittelpunkt\ und\ Radius\r\n\ \r\n\ @author\ Lasse\ Huber-Saffer\r\n\ @version\ 24.12.2021\r\n
comment1.params=position\ radius\ layer
comment1.target=CircleCollider(Vector2,\ double,\ PhysicsLayer)
comment1.text=\r\n\ Konstruktor\ f\u00FCr\ Objekte\ der\ Klasse\ CircleCollider\r\n\ @param\ position\ Mittelpunkt\ des\ Kreises\r\n\ @param\ radius\ radius\ des\ Kreises\ (>\ 0.0)\r\n\ @param\ layer\ Physik-Ebene\ auf\ der\ dieser\ Collider\ agiert\r\n
comment10.params=
comment10.target=ICollisionListener\ getListener()
comment10.text=\r\n\ @see\ ICollider\#getListener()\r\n
comment11.params=listener
comment11.target=void\ setListener(ICollisionListener)
comment11.text=\r\n\ @see\ ICollider\#setListener()\r\n
comment12.params=
comment12.target=PhysicsLayer\ getLayer()
comment12.text=\r\n\ @see\ ICollider\#getLayer()\r\n
comment13.params=layer
comment13.target=void\ setLayer(PhysicsLayer)
comment13.text=\r\n\ @see\ ICollider\#setLayer()\r\n
comment14.params=
comment14.target=Vector2\ getPosition()
comment14.text=\r\n\ Gibt\ den\ Mittelpunkt\ des\ Kreises\ zur\u00FCck\r\n\ @return\ Mittelpunkt\ des\ Kreises\r\n
comment15.params=
comment15.target=double\ getRadius()
comment15.text=\r\n\ Gibt\ den\ Radius\ des\ Kreises\ zur\u00FCck\r\n\ @return\ Radius\ des\ Kreises\r\n
comment16.params=position
comment16.target=void\ setPosition(Vector2)
comment16.text=\r\n\ Setzt\ den\ Mittelpunkt\ des\ Kreises\r\n\ @param\ position\ Position\ des\ Kreismittelpunktes\r\n
comment17.params=radius
comment17.target=void\ setRadius(double)
comment17.text=\r\n\ Setzt\ den\ Radius\ des\ Kreises\r\n\ @param\ radius\ Radius\ des\ Kreises\ (>\ 0.0)\r\n
comment2.params=other
comment2.target=boolean\ intersects(ICollider)
comment2.text=\r\n\ @see\ ICollider\#intersect()\r\n
comment3.params=other
comment3.target=boolean\ detectCollision(ICollider)
comment3.text=\r\n\ @see\ ICollider\#detectCollision()\r\n
comment4.params=otherCircle
comment4.target=double\ getCircleOverlap(CircleCollider)
comment4.text=\r\n\ Berechnet\ die\ maximale\ \u00DCberschneidungstiefe\ mit\ einem\ anderen\ Kreis-Collider\r\n\ @param\ otherCircle\ anderer\ Kreis-Collider\r\n
comment5.params=other
comment5.target=void\ resolveCollision(ICollider)
comment5.text=\r\n\ Bewegt\ diesen\ Collider,\ um\ eine\ Kollision\ mit\ einem\ gegebenen\ Collider\ aufzul\u00F6sen.\r\n\ Im\ Falle\ einer\ tats\u00E4chlichen\ Bewegung\ wird\ die\ Methode\ onResolution\ des\ Listeners\ ausgef\u00FChrt.\r\n\ @param\ otherLine\ Collider,\ dem\ ausgewichen\ werden\ soll\ (Line\ oder\ Circle)\r\n
comment6.params=otherLine
comment6.target=void\ resolveLineCollision(LineCollider)
comment6.text=\r\n\ Bewegt\ diesen\ Collider,\ um\ eine\ Kollision\ mit\ einem\ gegebenen\ LineCollider\ aufzul\u00F6sen.\r\n\ @param\ otherLine\ LineCollider,\ dem\ ausgewichen\ werden\ soll\r\n
comment7.params=otherCircle
comment7.target=void\ resolveCircleCollision(CircleCollider)
comment7.text=\r\n\ Bewegt\ diesen\ Collider,\ um\ eine\ Kollision\ mit\ einem\ gegebenen\ CircleCollider\ aufzul\u00F6sen.\r\n\ @param\ otherCircle\ CircleCollider,\ dem\ ausgewichen\ werden\ soll\r\n
comment8.params=otherLine
comment8.target=LineCircleIntersection\ getLineIntersection(LineCollider)
comment8.text=\r\n\ Gibt\ den\ Schnitt\ dieses\ CircleColliders\ mit\ einer\ Linie\r\n\ @param\ otherLine\ Linie,\ mit\ der\ der\ Schnitt\ berechnet\ werden\ soll\r\n\ @return\ Ergebnis\ des\ Schnitts\r\n
comment9.params=translation
comment9.target=void\ move(Vector2)
comment9.text=\r\n\ Bewegt\ diesen\ Kreis\ um\ einen\ Bewegungsvektor\r\n\ @param\ translation\ Bewegungsvektor\r\n
numComments=18
